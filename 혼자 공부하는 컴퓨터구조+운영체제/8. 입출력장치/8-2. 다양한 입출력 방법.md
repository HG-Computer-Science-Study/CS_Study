### 키워드

`프로그램 입출력`, `메모리 맵 입출력`, `고립형 입출력`, `인터럽트 기반 입출력`, `DMA 입출력`, `입출력 버스`

### 시작하기 전에

- 장치 컨트롤러가 CPU와 정보를 주고받는 방법 : 프로그램 입출력, 인터럽트 기반 입출력, DMA입출력

# 프로그램 입출력

- **프로그램 입출력** : 프로그램 속 명령어로 입출력장치를 제어하는 방법
  - CPU는 입출력 명령어를 만나면 장치 컨트롤러와 상호작용하며 입출력 작업 수행
- 예시 : 메모리에 저장된 정보를 하드 디스크에 백업하는 상황
  ![Image](https://github.com/user-attachments/assets/e6c3f6d2-e824-48f5-b966-0784fffd8b21)
  1. CPU는 하드 디스크 컨트롤러의 **제어 레지스터**에 쓰기 명령을 보냄
  2. 하드 디스크 컨트롤러가 하드 디스크 상태 확인. 준비된 상태라면 **상태 레지스터**에 준비 완료 표시
  3. CPU는 상태 레지스터를 주기적으로 읽어보며 준비 여부를 확인하고, 준비 완료시 **데이터 레지스터**에 백업할 정보를 씀
  4. 1번부터 반복
- 위와 같은 작업을 하는 방식은 2가지 : 메모리 맵 입출력, 고립형 입출력

### 1) 메모리 맵 입출력

- **메모리 맵 입출력** : 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법
  ![Image](https://github.com/user-attachments/assets/1c68ed1e-f3ed-4777-9a6c-57600ed33855)

  - 1024개의 주소를 표현할 수 있는 컴퓨터
    - 512개는 메모리 주소 표현
    - 나머지 512개는 장치 컨트롤러의 레지스터 표현

- CPU는 메모리의 주소들이나 장치 컨트롤러의 레지스터들이나 모두 똑같이 메모리 주소를 대하듯 하면 된다
  - 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어가 같다

### 2) 고립형 입출력

- **고립형 입출력** : 메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법
  ![Image](https://github.com/user-attachments/assets/43793245-709d-4e00-873d-02da2c88d0b3)

- CPU가 입출력장치에 접근하기 위한 명령어와 메모리에 접근하는 명령어가 다르다
- 메모리 주소 공간과 입출력장치를 위한 주소 공간이 줄어들지 않는다

### 3) 메모리 맵 입출력 vs 고립형 입출력

| **메모리 맵 입출력**                          | **고립형 입출력**                           |
| --------------------------------------------- | ------------------------------------------- |
| 메모리와 입출력장치는 같은 주소 공간 사용     | 메모리와 입출력장치는 분리된 주소 공간 사용 |
| 메모리 주소 공간이 축소됨                     | 메모리 주소 공간이 축소되지 않음            |
| 메모리와 입출력장치에서 같은 명령어 사용 가능 | 입출력 전용 명령어 사용                     |

# 인터럽트 기반 입출력

- **인터럽트 기반 입출력** : 인터럽트를 기반으로 하는 입출력
  - 입출력장치가 작업을 끝내면 장치 컨트롤러가 CPU에게 인터럽트 요청 신호를 보낸다
  - CPU는 작업을 백업하고 인터럽트 서비스 루틴을 실행한다.

<aside>
💡

**폴링 (polling)**

- 입출력장치의 상태, 처리할 데이터 유무를 주기적으로 확인하는 방식
- 인터럽트 방식보다 CPU의 부담이 더 크다
</aside>

## 여러 입출력 장치에서 인터럽트가 동시에 발생한 경우

### 1) 순차적으로 처리

- 인터럽트 A를 처리하는 도중 발생한 인터럽트 B는, A의 처리가 끝난 후 처리한다
- CPU가 플래그 레지스터 속 인터럽트 비트를 비활성화한 채 인터럽트를 처리하는 경우 순차적으로 인터럽트를 처리할 수 있다.
  - 인터럽트 처리 중에 다른 입출력장치에 의한 인터럽트를 받아들이지 않기 때문이다.

### 2) 우선순위대로 처리

- 인터럽트 간에 우선순위를 고려하여 우선순위가 높은 인터럽트 순으로 여러 인터럽트를 처리한다
  - 플래그 레지스터 속 인터럽트 비트가 활성화되어있는 경우
  - 인터럽트 비트가 비활성화되어있지만 NMI(무시할 수 없는 인터럽트, Non-Maskable Interrupt)가 발생한 경우
- **PIC (Programmable Interrupt Controller)**
  - 우선순위를 반영하여 다중 인터럽트를 처리하는 하드웨어
  - PIC는 장치 컨트롤러와 CPU 중간에서 오가는 신호들을 매개한다
    1. PIC가 장치 컨트롤러에서 인터럽트 요청 신호들을 받는다
    2. PIC는 우선순위를 판단한 뒤 CPU에 처리해야 할 인터럽트 요청 신호를 보낸다
    3. CPU는 PIC에 인터럽트 확인 신호를 보낸다
    4. PIC는 CPU에 인터럽트 벡터를 보낸다
    5. CPU는 인터럽트 서비스 루틴을 실행한다.
  - PIC가 NMI까지 우선순위를 판별하지는 않는다. NMI의 우선순위가 가장 높기 때문이다.

# DMA 입출력

- **DMA(Direct Memory Access)** : 입출력장치가 CPU를 거치지 않고 직접 메모리에 접근할 수 있는 입출력 기능
- **DMA 컨트롤러** : 시스템 버스에 연결된 하드웨어로 DMA 입출력을 하기 위해 필요함

### 1) DMA 입출력 과정

- DMA 입출력 과정

  1. CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산, 메모리의 주소 등의 정보로 입출력 작업 명령
  2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력작업 수행

     → 이 때 DMA 컨트롤러가 메모리와 직접 상호작용

  3. 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알림

- 문제 : 시스템버스는 공용자원이기 때문에 DMA 컨트롤러와 CPU가 동시에 사용할 수 없다
  - 참고 : DMA 컨트롤러는 메모리와 장치 컨트롤러, CPU에 접근할 때 시스템버스를 사용한다
  - **사이클 스틸링 (Cycle Stealing)** : CPU가 시스템 버스를 이용하지 않을 때나 CPU가 일시적으로 시스템 버스를 사용하지 않도록 하고 DMA 컨트롤러가 시스템버스를 이용하는 것

### 2) 입출력 버스

- DMA 컨트롤러와 장치 컨트롤러들을 **입출력 버스**에 연결하면 시스템 버스의 사용 빈도를 줄일 수 있다.
  ![Image](https://github.com/user-attachments/assets/c3c0639f-2ce3-4f1c-b677-470ff6f7f51a)

- 입출력 버스의 종류 : PCI 버스, PIC Express(PCIe) 버스 등
- **PCIe 슬롯** : 입출력장치들을 PICe 버스와 연결해주는 하드웨어

<aside>
💡

**입출력 채널 (입출력 프로세서)**

- 메모리에 직접 접근하고, 입출력 명령어를 직접 인출하고, 해석하고, 실행하는 입출력 전용 CPU
- 최신 입출력장치 내부에는 별도의 입출력 프로세서가 포함되어있다
- 컴퓨터 CPU가 입출력 명령어를 실행하지 않기 때문에 CPU의 부담이 줄어든다.
</aside>
