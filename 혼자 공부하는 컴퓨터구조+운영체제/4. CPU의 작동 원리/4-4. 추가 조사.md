## 1. 각 주소 지정 방식이 사용되는 상황

### 1) 스택 주소 지정 방식

- **함수 호출과 리턴** : 함수 호출 시, 현재 함수의 상태(리턴 주소)를 저장하거나, 매개변수와 지역 변수를 관리할 때 사용
  - `CALL func` : 현재 명령어 주소를 스택에 **PUSH**하고, 함수의 시작 주소로 점프
  - `RET` : 스택에서 리턴 주소를 **POP**하여 호출 위치로 복귀
- **중간 연산 결과 관리** : 계산 중간 값을 스택에 저장하고 필요 시 꺼내 쓰는 경우
  ```nasm
  PUSH R1      ; 레지스터 R1의 값을 스택에 저장
  PUSH R2      ; 레지스터 R2의 값을 스택에 저장
  POP R3       ; 스택에서 값을 꺼내 R3에 저장 (중간 결과)
  ```
- **재귀 함수 처리** : 재귀적으로 호출되는 함수에서 호출 스택을 유지하기 위해 사용
  - 재귀적으로 호출될 때 각 호출 상태(지역 변수, 리턴 주소 등)를 스택에 저장하여 각 호출의 독립성을 유지

### 2) 상대 주소 지정 방식

- **분기, 점프** : 프로그램의 흐름을 변경할 때 상대 주소를 사용하여 간결하고 재배치 가능하게 설계
  ```nasm
  MOV R1, 10      ; R1에 10을 저장
  CMP R1, 0       ; R1과 0을 비교
  BEQ -4          ; 비교 결과가 0(같음)일 경우 4바이트 이전 명령으로 점프
  ```
- **조건부 분기** : 특정 조건이 참일 때만 상대적인 위치로 이동(예: if-else).
  ```nasm
  LOOP_START:
      SUB R1, 1   ; R1에서 1을 뺌
      BNE LOOP_START ; R1이 0이 아니면 루프의 시작으로 이동
  ```
- **코드 재배치 가능성** : 프로그램이 메모리의 다른 위치로 옮겨지더라도 상대 주소는 여전히 유효

### 3) 베이스 레지스터 주소 지정 방식

- **배열 및 데이터 구조 접근** : 배열의 특정 요소에 접근할 때, 베이스 레지스터가 배열 시작 주소를 저장하고, 인덱스(오프셋)를 더해 접근
  ```nasm
  MOV R2, 1000      ; R2에 배열의 시작 주소 저장
  MOV R3, 4         ; 인덱스 4를 R3에 저장
  ADD R3, R3, R3    ; 인덱스 4에 요소 크기(2바이트) 곱하기 (예: 2)
  MOV R1, [R2+R3]   ; 배열 시작 주소 + 4번째 요소 주소로 데이터 읽기
  ```
- **다중 사용자 메모리 시스템** : 여러 사용자나 프로세스의 메모리를 분리하여 관리
  ```nasm
  ; 사용자 A의 시작 주소 : 베이스 레지스터에 저장
  ; 사용자 B의 시작 주소 : 다른 베이스 레지스터에 저장
  MOV BASE_REG_A, 2000  ; 사용자 A의 메모리 블록 시작 주소
  MOV BASE_REG_B, 4000  ; 사용자 B의 메모리 블록 시작 주소
  MOV R1, [BASE_REG_A+OFFSET] ; 사용자 A의 메모리에서 데이터 읽기
  ```
- **가변 크기 데이터 구조** : 구조체와 같이 크기가 가변적인 데이터 구조에 접근

### 4) 비교

| **주소 지정 방식**       | **상황**                                   | **구체적 예시**                             |
| ------------------------ | ------------------------------------------ | ------------------------------------------- |
| **스택 주소 지정 방식**  | 함수 호출/리턴, 재귀, 중간 계산값 관리     | 함수 호출 스택, PUSH/POP                    |
| **상대 주소 지정 방식**  | 분기, 점프, 조건부 명령, 코드 재배치       | 루프, 조건부 분기 (BEQ, BNE 등)             |
| **베이스 레지스터 방식** | 배열, 구조체 접근, 다중 사용자 메모리 관리 | 배열 인덱스 계산, 사용자별 메모리 블록 접근 |

### 5) CPU는 각 상황에 어떤 주소 지정 방식을 쓸 건지 어떻게 판단?

**명령어 포맷과 오퍼코드**에 따라 주소 지정 방식을 자동으로 선택하며, **컴파일러와 어셈블러**가 최적의 방식을 지정한다.

1. **명령어 포맷**
   - CPU는 명령어의 **오퍼코드(Opcode)**와 **명령어 포맷**을 기반으로 어떤 주소 지정 방식을 사용할지 판단
   - 명령어 자체에 주소 지정 방식에 대한 정보가 포함된다
     | **기법**                 | **예시**                                                                            |
     | ------------------------ | ----------------------------------------------------------------------------------- |
     | **오퍼코드의 특정 비트** | x86의 `ModR/M` 바이트 : 비트를 통해 레지스터/메모리 연산 여부와 주소 지정 방식 결정 |
     | **명령어 접미사**        | `LDR` (ARM), `MOV AL` (x86) 등 : 데이터 크기나 메모리 접근 방식 구분                |
     | **암묵적 규칙**          | 스택 연산(`PUSH/POP`), 분기(`JMP/BEQ`) : 명령어 성격에 따라 주소 지정 방식 고정     |
2. **컴파일러와 어셈블러**
   - 고급 언어 코드를 분석하여 적절한 주소 지정 방식을 선택
     - **스택 주소 지정 방식**: 함수 호출 시 스택 구조에 접근하는 명령어로 변환.
     - **상대 주소 지정 방식**: 분기나 점프 명령어를 사용하여 상대적인 오프셋을 계산.
     - **베이스 레지스터 주소 지정 방식**: 배열이나 데이터 구조의 참조를 계산.
3. **CPU 내부 제어 논리**
   - CPU는 **명령어 디코더**를 통해 명령어를 해석하고, 해당 주소 지정 방식을 적용.
   - 디코더는 명령어와 함께 제공된 레지스터나 오프셋 값을 해석하여 메모리 주소를 계산

## 2. 인터럽트 서비스 루틴을 실행하던 도중 또 다른 인터럽트가 발생한다면 어떻게 처리?

위와 같은 경우 **인터럽트 중첩(interrupt nesting)** 문제가 생길 수 있다. 이 문제를 해결하기 위해 일반적으로 다음과 같은 전략을 사용한다.

### 1) 인터럽트 우선순위에 따른 처리

대부분의 CPU는 **우선순위(priority)** 시스템을 사용하여 동시에 발생하거나 중첩되는 인터럽트를 처리한다.

- **높은 우선순위 인터럽트**는 현재 실행 중인 **낮은 우선순위 ISR**을 **중단하고 처리**할 수 있다
- 반면, **낮은 우선순위 인터럽트**는 현재 ISR이 끝날 때까지 대기한다.
- 동작 과정
  1. 현재 실행 중인 ISR이 중요한 상태 정보를 **스택에 저장**.
  2. 높은 우선순위 인터럽트가 발생하면 ISR을 일시 중단하고 새로운 ISR을 실행.
  3. 새로운 ISR이 끝난 후, 스택에서 상태 정보를 복원하고 중단된 ISR을 이어서 실행.

### 2) 인터럽트 디스에이블

- 특정 인터럽트를 처리하는 동안 **다른 모든 인터럽트를 임시로 비활성화**하여 중첩을 방지함
- 이 방식은 시스템의 안정성을 높이지만, 높은 우선순위 인터럽트를 지연시킬 위험이 있다.
- 동작 과정
  1. CPU는 특정 ISR 실행 중에 인터럽트를 **마스크(masking)** 처리하여 새 인터럽트를 차단.
  2. ISR이 완료되면 인터럽트를 다시 활성화.

### 3) 인터럽트 벡터 테이블과 우선순위 할당

**인터럽트 벡터 테이블**과 **우선순위 할당** 메커니즘을 사용하여 중첩을 처리한다.

- 각 인터럽트 요청에 대해 고유한 벡터(주소)가 할당되어 ISR 실행을 관리.
- 우선순위가 명시된 경우 높은 우선순위부터 처리.

### 4) 소프트웨어에서의 인터럽트 관리

- **임계 구역(Critical Section)** : 소프트웨어적으로 특정 코드 영역에서 인터럽트를 비활성화하여 중요한 작업이 중단되지 않도록 보장.
- **플래그 사용** : ISR이 실행 중임을 나타내는 플래그를 설정하여, 새 인터럽트가 들어와도 ISR이 끝날 때까지 대기하도록 구현.

## 3. CPU 멀티코어 환경에서는 인터럽트를 어떻게 처리?

멀티코어 환경에서의 인터럽트 처리는 **부하 분산, 우선순위 관리, 코어 간 협력**이 핵심적이다.

### 1) 대칭 인터럽트 처리

- 모든 코어가 인터럽트를 처리하도록 한다
- 인터럽트 컨트롤러가 발생한 인터럽트를 분산하여 각 코어에 전달하여 부하를 분산한다.
- 사전 정의된 규칙에 따라 코어를 정적으로 선택하기 때문에 실시간 부하 분산에 대한 고려가 부족하다
- 예시
  1. APIC (Advanced Programmable Interrupt Controller) : 인텔 x86 멀티코어 프로세서에서 사용
  2. IRQ 스티어링 : 운영체제가 인터럽트를 각 코어에 적절히 할당

### 2) 비대칭 인터럽트 처리

- 특정 코어만 인터럽트를 전담해서 처리
- 인터럽트 처리가 특정 코어로 한정되어 설계와 디버깅이 단순하다
- 특정 코어에 부하가 집중될 수 있다

### 3) 인터럽트 부하 분산

- 인터럽트를 동적으로 여러 코어에 분산
- 운영체제가 부하를 모니터링하고, 인터럽트의 처리 코어를 실시간으로 재배치한다
- 실시간 부하 상태에 따라 코어를 동적으로 선택하기 때문에 효율성이 높다
- 네트워크 트래픽, 디스크 I/O같은 고빈도 인터럽트 처리에 유용하다
- 예시
  1. IRQ Affinity : 운영체제가 특정 인터럽트를 특정 코어에 할당하거나 재배치
  2. MSI-X : 네트워크 카드에서 인터럽트를 여러 코어에 분산

### 4) 코어 간 인터럽트

- 한 코어가 다른 코어를 깨우거나 특정 작업을 수행하도록 요청할 때 사용
- 코어 간 협력 및 동기화에 사용
- 주로 스케줄링, 캐시 동기화, 태스크 간 통신에서 활용
- 예시
  - 멀티코어 운영체제 : CPU 0이 인터럽트를 받아 스케줄링 작업을 수행하고, IPI를 통해 다른 코어를 깨워 태스크를 할당
