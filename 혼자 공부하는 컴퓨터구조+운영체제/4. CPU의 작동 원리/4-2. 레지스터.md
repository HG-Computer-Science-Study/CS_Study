### 키워드

`프로그램 카운터`, `명령어 레지스터`, `메모리 주소/버퍼 레지스터`, `범용/플래그 레지스터`, `스택 포인터`, `베이스 레지스터`

# 반드시 알아야 할 레지스터

### 1. 프로그램 카운터 (= 명령어 포인터)

- 메모리에서 **읽어 들일 명령어**의 주소를 저장

### 2. 명령어 레지스터

- 메모리에서 **읽어 들인 명령어**(해석할 명령어)를 저장

### 3. 메모리 주소 레지스터

- 메모리의 주소 저장
- CPU가 읽어들이고자 하는 **주소 값을 주소 버스로 보낼 때** 거친다

### 4. 메모리 버퍼 레지스터

- 메모리와 주고받을 값(데이터와 명령어)을 저장
- **데이터 버스로 주고받을 값**은 메모리 버퍼 레지스터를 거친다

### 5. 범용 레지스터

- 다양하고 일반적인 상황에서 자유롭게 사용
- 데이터와 주소 모두 저장 가능

### 6. 플래그 레지스터

- 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장

<aside>
💡

**메모리에 저장된 프로그램을 실행하는 과정**

1. 메모리의 1000번지에 명령어가 저장되어있다
2. **프로그램 카운터**에 1000번지를 저장한다.
3. 주소를 읽어들여야 하므로 **메모리 주소 레지스터**에 1000번지를 저장한다.
4. 메모리 읽기 제어 신호는 제어 버스, **메모리 주소 레지스터 값이 주소 버스를 통해** 메모리로 전송된다.
5. 메모리 1000번지에 저장된 값이 **데이터 버스를 통해 메모리 버퍼 레지스터로** 전달된다. 프로그램 카운터는 1001로 증가되어 다음 명령어를 읽을 준비를 한다.

   ⇒ CPU가 메모리 속 프로그램을 순차적으로 읽어들이고 실행할 수 있는 이유는 CPU속 프로그램 카운터가 꾸준히 증가하기 때문이다.

6. 메모리 버퍼 레지스터에 저장된 값이 **명령어 레지스터**로 이동한다
7. 제어장치가 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킨다 → 1000번지 명령어 처리 완료
8. CPU가 다음 명령어(1001번지)를 읽어들인다 → 반복
</aside>

<aside>
💡

**순차적인 실행 흐름이 끊기는 이유**

- 프로그램 카운터가 실행중인 명령어의 다음 번지 주소가 아닌 전혀 다른 값으로 업데이트되는 경우 - JUMP, CONDITIONAL JUMP, CALL, RET과 같은 명령어가 실행되는 경우 - 인터럽트가 발생하는 경우
</aside>

# 특정 레지스터를 이용한 주소 지정 방식

- 주소 지정에 사용될 수 있는 레지스터
  - 프로그램 카운터, 베이스 레지스터 : **변위 주소 지정 방식**
  - 스택 포인터 : **스택 주소 지정 방식**

## 1) 스택 주소 지정 방식

- **스택 주소 지정 방식** : 스택과 스택 포인터를 이용한 주소 지정 방식
- **스택 포인터** : 스택의 꼭대기를 가리키는 레지스터 (마지막으로 저장한 값의 **위치** 저장)
  - 주의 : 스택 포인터에는 데이터값이 아니라 데이터의 주소가 저장된다
- **스택 영역** : 메모리 안에 스택처럼 사용하기로 약속된 영역
  참고 : 여기에서 말하는 ‘스택’은 **메모리 안의 스택 영역**을 가리킨다.

## 2) 변위 주소 지정 방식

<aside>
💡

**복습 : 명령어의 구조**

- 명령어는 연산 코드와 오퍼랜드로 구성된다
- 오퍼랜드 필드에는 메모리의 주소가 저장될 수 있다.
</aside>

- **변위 주소 지정 방식** : 오퍼랜드 필드의 값(변위)과 특정 레지스터 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
  ![image (7)](https://github.com/user-attachments/assets/1ef5a8e6-b82d-4762-9046-da7dcf435ed5)
  ⇒ 변위 주소 지정 방식을 사용하는 명령어는 **연산 코드 필드**, 어떤 레지스터의 값과 더할지 나타내는 **레지스터 필드**, 주소를 담고 있는 **오퍼랜드 필드**가 있다.
- **변위 주소 지정 방식의 종류**
  1. 상대 주소 지정 방식
  2. 베이스 레지스터 주소 지정 방식

### 상대 주소 지정 방식

- **오퍼랜드**와 **프로그램 카운터**의 값을 더하여 유효 주소를 얻는 방식
  - 프로그램 카운터 : 읽어들일 명령어의 주소가 저장되어 있음
  - 따라서 다음과 같이 동작함
    - 오퍼랜드 = -3인 경우 : 실행하려는 명령어의 세 칸 이전 번지 명령어 실행
    - 오퍼랜드 = 3인 경우 : 실행하려는 명령어에서 세 칸 건너뛴 번지 실행
- 상대 주소 지정 방식의 용도
  1. 분기 명령어 처리 : 프로그램 실행 중 조건에 따라 특정 코드 블록으로 분기해야 할 때 유용하다
  2. 동적 데이터 참조 : 실행중인 프로그램이 자주 변경되는 데이터 구조나 동적 데이터 영역(ex. 스택, 힙 등)을 참조할 때 유용하다.

### 베이스 레지스터 주소 지정 방식

- **오퍼랜드**와 **베이스 레지스터**의 값을 더하여 유효 주소를 얻는 방식
  - 베이스 레지스터 : 기준 주소의 역할을 함
  - 오퍼랜드 : 기준 주소로부터 떨어진 거리로서의 역할을 함
- **상대 주소 지정 방식 vs 베이스 레지스터 주소 지정 방식**
  | **특징** | **상대 주소 지정 방식** | **베이스 레지스터 주소 지정 방식** |
  | --------------------------------------------------------------------------------------------------------------------- | --------------------------------------------- | --------------------------------------- |
  | **기준 주소** | 프로그램 카운터 | 베이스 레지스터 |
  | **기준 주소의 용도** | 현재 명령어 위치 | 데이터 시작 주소 |
  | **주소 계산의 유동성** | 동적으로 **변한다** (프로그램 실행 중 프로그램 카운터 값이 계속 변하기 때문) |**고정** 또는 필요 시 변경 가능 (베이스 레지스터 값은 보통 프로그램 실행 중 고정되어 있으며, 필요한 경우 프로그래머나 운영체제가 값을 변경할 수 있다)
  | **주로 사용되는 용도** | 분기, 점프, 함수 호출 등 **명령어 흐름 제어** | **데이터 접근** (배열, 구조체, 스택 등) |
  | **운영 체제와의 연관성** | 실행 중인 명령어 위치와 연관 | 메모리 관리 및 프로세스 격리와 연관 |
