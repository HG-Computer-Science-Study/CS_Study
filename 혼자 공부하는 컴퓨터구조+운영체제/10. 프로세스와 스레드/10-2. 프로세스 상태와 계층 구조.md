## 프로세스 상태

### 생성 상태 (new)

- 프로세스를 생성 중인 상태를 생성 상태라고 한다. 이제 막 메모리에 적재되어 PCB를 받은 상태이다.
- 생성 상태를 거쳐 실행할 준비가 완료된 프로세스는 곧바로 실행되지 않고 준비 상태가 되어 CPU 할당을 기다린다.

### 준비 상태 (ready)

- 당장 CPU 할당을 받을 수 있지만 아직 자신의 차례가 아니기에 기다리는 상태이다.

### 실행 상태 (running)

- 프로세스가 CPU를 할당받아 실행 중인 상태를 의미한다. 실행 상태인 프로세스는 할당된 일정 시간 동안만 CPU를 사용할 수 있다.
- 이때 프로세스가 할당된 시간을 모두 사용하면 다시 준비 상태가 되고(타이머 인터럽트), 실행 도중 입출력장치를 사용하여 입출력장치의 작업이 끝날 때까지 기다려야 한다면 대기 상태가 된다.

### 대기 상태 (waiting)

- 프로세스가 실행 도중 입출력 작업의 결과를 기다리는 상태이다. (꼭 입출력이 아니어도 됨)
- 입출력 작업이 완료되면 해당 프로세스는 다시 준비 상태로 CPU 할당을 기다린다.

### 종료 상태 (terminated)

- 프로세스가 종료된 상태이다.
- 프로세스가 종료되면 운영체제는 PCB와 사용한 메모리를 정리한다.

![Image](https://github.com/user-attachments/assets/3045a422-5a64-47ef-aba1-56fcbf4807f7)
## 프로세스 계층 구조

- 프로세스는 실행 도중 System call 을 통해 다른 프로세스를 생성할 수 있다. 이때 부모 프로세스와 자식 프로세스가 생성된다.
- 부모와 자식은 엄연히 다른 프로세스여서 다른 PID를 가진다. (일부 운영체제에서는 자식 PID에 PPID(Parent PID) 기록)
- 자식 프로세스는 다시 자식 프로세스를 만들 수 있고… 계속 만들 수 있다.
- 그림을 그리면 다음과 같은 과정이 되는데 이를 프로세스 계층 구조라고 한다.

![Image](https://github.com/user-attachments/assets/ee33fbbb-e662-40f6-9415-6de1e9f52f0c)
## 프로세스 생성 기법

- 프로세스는 `fork()`, `exec()` 을 통해 프로세스를 생성할 수 있다.
- 2개 모두 System call에 해당한다

### Fork

- 자신의 복사본을 자식 프로세스로 생성한다.
- 자식 프로세스는 부모의 복사본이여서 부모와 거의 모든 정보가 일치한다. (PID, 저장된 메모리 주소 위치 제외) ⇒ PCB도 복제하지만 PID는 다르다는 말이다.
- 자식 프로세스의 PCB에는 PID, PPID 모두 기록된다.

### Exec

- 자신의 메모리 공간을 새로운 프로그램을 덮어쓴다.
- PID, PPID는 같지만 당연히 저장된 코드 영역과 데이터 영역의 내용이 바뀐다.
- 아래는 간단하게 정리한 표이다.

| 명령어 | fork() | exec() |
| --- | --- | --- |
| 프로세스 생성 여부 | 새로운 프로세스를 생성 | 프로세스를 생성하지 않음 |
| 내용 | 부모와 자식 내용이 같음 | `exec()` 전후 내용이 다름 |
| 메모리 | 자식 프로세스를 위해 새로 메모리 주소 할당 | 새로 할당하지 않고 기존에 존재하던 `exec()`에 의해 호출된 프로세스의 메모리 주소 사용 |
| 특징 | `fork()` 명령어가 끝나면 부모는 그 다음 명령어를 자연스럽게 진행하고, 자식 프로세스도 `fork()` 다음부터 진행한다. 둘이 별도로 진행되는 것임 | 단순히 exec()을 하게 되면 기존에 실행하던 프로세스가 완전히 덮어씌워지기 때문에 fork() → exec() 과정을 거쳐야 한다. |