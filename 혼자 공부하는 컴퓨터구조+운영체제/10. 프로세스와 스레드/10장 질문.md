# 웹 서버(Apache, Nginx)는 멀티 프로세스와 멀티 스레드 중 어떤 방식을 사용할까요?

## Apache 웹 서버

### Apache 기본 구조

- 새로운 클라이언트의 요청이 들어올 때마다 커넥션을 형성하기 위해 프로세스를 생성함.
- 프로세스를 만드는 일은 시간이 오래 걸리기 때문에, 요청이 들어오기 전에 미리 프로세스를 만들어 놓은 `prefork` 방식을 사용함.
- 장점?
    - 개발하기 쉬워서 개발자가 다양한 모듈을 만들어서 서버에 기능을 추가할 수 있었음.
    - 확장성이 너무 좋았음.

> 하지만 요청이 많아지면서 문제가 생기는데, 서버와 동시에 연결한 커넥션이 많아졌을 때 더 이상 커넥션을 생성하지 못함. 이를 `C10K` 문제라고 한다. (Connection 10000 개)
>

<aside>
💡
http 프로토콜을 보면 header의 종류 중에 'keep alive' 헤더가 있는데,

이 header에 적힌 시간만큼 클라이언트와 서버는 한번 형성한 **커넥션을 계속 유지한다.**

이는 곧 **메모리 부족**으로 이어진다!

</aside>

- 많은 동시 커넥션에서 요청이 들어오면 CPU 코어는 계속해서 프로세스를 바꿔가며 일을 해야 하는데, 이는 **Context Switching 이 많이 발생한다**는 것이므로 오버헤드가 굉장히 크다.

## Nginx 웹 서버

- 위에서 언급한 Apache 웹 서버의 문제점을 해결하기 위해서 등장하였다.
- Apache 웹 서버 앞단에 Nginx를 두면 수많은 동시 커넥션을 Nginx가 대신하여 유지할 수 있다.

![Image](https://github.com/user-attachments/assets/071dd957-eca1-4c19-a16a-20da5d063533)

- Nginx는 그 자체로 웹 서버이기에 정적 파일에 대한 요청은 스스로 처리가 가능하다. 따라서 동적 파일에 대한 요청을 받았을 때만 뒤에 있는 서버와 커넥션을 형성한다.

### Nginx는 어떤 구조인가? - 이벤트 기반 구조

- **마스터 프로세스**가 존재하고 설정 파일을 읽고, 설정에 맞게 **워커 프로세스**를 생성하는 프로세스이다.
    - 워커 프로세스가 실제로 일을 하는 프로세스이다.
    - 워커 프로세스가 만들어질 때 각자 지정된 Listen 소켓을 배정받는다.
    - 그 소켓에 새로운 클라이언트의 요청이 들어오면 커넥션을 형성하고 그 요청을 처리한다.
        - 커넥션이 형성되었다고 해서 워커 프로세스가 해당 커넥션 1개만 담당하는건 아니고, 형성된 커넥션에서 아무런 요청이 없으면 **새로운 커넥션을 형성**하거나 **기존에 있는 커넥션에 들어온 요청을 처리**할 수도 있다.
- Nginx에서는 이런 커넥션 형성, 커넥션 제거, 그리고 새로운 요청을 처리하는 것을 **이벤트**라고 한다.

![Image](https://github.com/user-attachments/assets/bccf3f86-c689-4095-beba-a15f9867b41f)

- 여러 이벤트들이 큐에 담기고, 워커 프로세스는 이것들을 비동기 방식으로 처리한다. 워커 프로세스는 하나의 스레드로 해당 이벤트를 처리한다.
- 워커 프로세스가 쉬지 않고 계속해서 일을 한다는 장점이 있다.

![Image](https://github.com/user-attachments/assets/3ea8f676-907b-4947-8a9e-a3396094c7b7)

- 만약 오래 걸리는 작업이 있는 경우 워커 프로세스는 해당 스레드 풀에 그 이벤트를 위임하고, 큐 안에 있는 다른 이벤트를 처리한다.

## Apache 웹 서버의 최근 근황

- 대규모 트래픽 처리를 하기 위해 **MPM(Multi-Processing Module) 모듈**을 사용
    - 여러 프로세스 내에서 각각 여러 스레드를 생성하여 요청을 동시에 처리합니다.
    - **장점 :** 프로세스 간 격리와 스레드의 효율성을 동시에 활용하여, 메모리 사용량을 절감하면서 높은 동시 처리 성능을 구현할 수 있습니다.

## 결론

- Apache 웹 서버의 경우 대규모 트래픽 처리를 하기 위해 **MPM(Multi-Processing Module) 모듈**을 사용하여 멀티 프로세스 + 멀티 스레드 혼합 방식을 사용한다.
- Nginx는 **멀티 프로세스** 구조를 기반으로, 각 워커 프로세스가 **이벤트 기반 단일 스레드** 모델로 동작하여, 높은 성능과 효율성을 실현

# fork()와 exec()를 사용했을 때 성능 저하나 리소스 사용에 어떤 차이가 있나요?

## 1. fork()의 동작과 비용

### **동작 원리**

- **프로세스 복제**
    - `fork()`는 현재 실행 중인 프로세스(부모)의 거의 모든 상태(주소 공간, 프로세스 제어 블록, 열린 파일 디스크립터 등)를 복제하여 새로운 프로세스(자식)를 생성한다.
- **Copy-On-Write (COW)**
    - 현대의 운영체제에서는 메모리 복사 비용을 줄이기 위해 **COW 기법**을 사용한다.
    - **즉각적인 메모리 복사 없이** 부모와 자식이 같은 물리적 메모리 페이지를 공유하다가, 어느 한쪽이 해당 페이지를 수정할 때 실제 복사가 일어난다.

### **성능 및 리소스 사용 측면**

- **커널 자료구조 할당:**
    - 프로세스 제어 블록(PCB), 페이지 테이블, 기타 커널 내부 자료구조를 생성 및 초기화해야 하므로, 시스템 콜 호출 자체에 일정한 오버헤드가 발생한다.
- **메모리 사용:**
    - COW 덕분에 `fork()` 직후에는 큰 메모리 복사가 발생하지 않지만, 자식 혹은 부모가 메모리를 수정하면 실제 복사 비용이 발생할 수 있다.
- **대량 프로세스 생성 시:**
    - 다수의 프로세스를 동시에 생성하면, 각 프로세스마다 PCB, 페이지 테이블, 열린 파일 디스크립터 등 커널 자원이 할당되므로, 전체 시스템의 커널 오버헤드가 증가한다.
    - 또한, 많은 프로세스가 존재하면 컨텍스트 스위칭 등 스케줄링 비용도 증가할 수 있다.

---

## 2. exec()의 동작과 비용

### **동작 원리**

- **실행 이미지 교체:**`exec()`는 현재 프로세스의 주소 공간을 새로운 실행 이미지(즉, 새로운 프로그램 코드, 데이터, 라이브러리 등)로 완전히 대체한다.
    - 이 과정에서 기존에 `fork()`로 생성된 자식 프로세스의 메모리 내용은 모두 해제되고, 새로운 프로그램을 실행하기 위한 메모리 공간이 할당된다.

### **성능 및 리소스 사용 측면**

- **디스크 I/O 및 초기화 비용:**
    - 새로운 실행 파일(바이너리)을 디스크에서 읽어 메모리에 로드하고, 필요한 라이브러리를 연결(linking)하며 초기화 과정을 거치므로, 디스크 I/O 및 초기화 비용이 발생한다.
    - 로드되는 파일의 크기와 동적 라이브러리의 수 등에 따라 오버헤드가 달라질 수 있다.
- **메모리 매핑 재구성:**
    - `exec()` 호출 시 기존의 주소 공간이 해제되고 새로운 주소 공간이 구성되므로, 이 과정에서 메모리 매핑과 관련된 오버헤드가 발생한다.

---

## 3. fork()와 exec()를 함께 사용하는 경우

- **일반적인 사용 패턴:**
    - 많은 시스템에서는 새로운 프로그램을 실행하기 위해 **`fork()`로 자식 프로세스를 생성한 후, 바로 `exec()`를 호출하여** 실행 이미지를 교체하는 패턴을 사용한다.
- **종합적인 비용:**
    - **`fork()`의 오버헤드:**
        - 커널 내부 자료구조(PCB, 페이지 테이블 등) 할당과 COW 기법에 따른 초기 비용.
    - **`exec()`의 오버헤드:**
        - 디스크에서 새로운 바이너리 로딩, 메모리 매핑, 동적 라이브러리 연결 등의 추가 비용.
    - **대량 프로세스 생성 시 누적 효과:**
        - 다수의 프로세스를 동시에 생성하면, `fork()`로 인한 커널 자료구조 관리 비용과 `exec()`로 인한 디스크 I/O 및 초기화 비용이 모두 누적되어 전체 시스템 성능에 영향을 줄 수 있다.

---

## 4. 추가 고려사항

- **vfork()의 활용:**
    - 만약 자식 프로세스가 즉시 `exec()`를 호출할 예정이라면, `vfork()`를 사용할 수 있다.
    - `vfork()`는 부모의 주소 공간을 공유하면서 자식이 `exec()`를 호출할 때까지 부모의 실행을 중단함으로써, fork() 시 발생하는 불필요한 메모리 복사나 커널 자료구조 할당 오버헤드를 줄일 수 있다.
- **컨텍스트 스위칭:**
    - 많은 프로세스가 생성되면 스케줄러가 각 프로세스 간의 컨텍스트 스위칭을 관리해야 하므로, CPU 오버헤드가 추가로 발생할 수 있다.