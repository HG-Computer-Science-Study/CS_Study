## RISC의 한계와 그 한계를 극복하기 위한 방안?

### RISC의 한계

- 코드 밀도 문제
    - RISC는 간단한 명령어로 복잡한 명령을 수행하다 보니, 특정 기능을 구현하기 위해 더 많은 명령어가 필요하다.
    - CISC에서는 하나의 명령어가 필요하지만 RISC에서는 여러 개의 명령어를 필요로 한다.
    - 결과적으로 코드의 크기가 증가한다.
- 메모리 접근 병목
    - RISC는 load/store 아키텍처를 따르며, 연산은 반드시 레지스터에 로드된 데이터에서만 수행된다.
    - 이 방식은 파이프라인 처리에는 효율적이지만, 데이터 접근이 잦은 응용 프로그램에서는 메모리 병목이 발생할 확률이 크다.

  > 메모리 병목 : CPU의 성능이 RAM, 캐시보다 훨씬 빠르기 때문에 발생하는 성능 제한 현상. CPU가 아무리 빨리져도 메모리 대기 시간 동안 대기해야 되는 문제이다.

- 깊은 파이프라인의 문제
    - RISC는 고속 처리를 위해 파이프라인을 깊게 설계하는데, 깊은 파이프라인은 분기 명령어의 예측 실패 시 복구 비용이 커진다.

  > 깊은 파이프라인 : 단계를 기존 파이프라인(Fetch,Decode,Instrument,Write Back)보다 더 세분화하여 15단계 이상으로 나눔.


### 해결하기 위한 방안?

- 최근에는 RISC, CISC을 결합한 아키텍처를 주로 사용한다.
- 외부적으로는 CISC 명령어를 지원, 내부적으로 RISC 명령어로 변환하여 사용하는 방식
- **AMD Ryzen (x86 기반)**
    - CISC 기반 외부 인터페이스 : 복잡한 x86 명령어 세트를 지원.
    - RISC 스타일 내부 처리 : x86 명령어를 **마이크로오퍼레이션** 이라는 단순한 명령어로 변환하여 처리한다.
- **Intel Core 시리즈 (x86 기반)**
    - 최신 아키텍처는 CISC 명령어의 복잡성을 유지하면서, RISC 스타일로 처리하여 전력 효율과 성능 간의 균형을 유지.
- **Apple Silicon (M1, M2)**
    - ARM 기반 RISC 아키텍처를 사용하지만, 내부적으로 CISC 스타일의 명령어를 일부 지원한다.
    - 뛰어난 전성비(Performance per Watt)로, 데스트탑 및 노트북에서 높은 성능과 긴 배터리 수명을 제공.

## CPU 성능 향상을 위해 많이 사용되는 기법?

- 멀티코어 및 멀티스레딩
- Out of Order Execution 및 명령어 파이프라이닝
- 고도화된 분기 예측 및 투기 실행
    - 분기 명령어로 파이프라이닝이 중단되는 문제를 줄이기 위해 CPU가 미리 분기 결과를 예측하여 다음 명령어를 실행하는 기법
    - 분기 예측 정확도가 높을수록 파이프라인의 대기 시간을 줄이고, 성능 손실을 최소화할 수 있음
- 캐시 메모리 및 프리패칭
    - CPU 내부에 L1,L2,L3 cache를 두어 메모리에 대한 접근 시간을 최소화하며, CPU가 곧 필요로 하는 데이터를 미리 불러오는 프리패칭 기법
        - 데이터 접근 지연 (Latency)을 크게 줄여 CPU가 지속적으로 데이터를 공급받아 고속 처리를 가능하게 함
        - **스트라이드(Strided) 프리패칭 :** 배열같이 일정한 간격으로 반복되는 경우 프리패칭이 유용하다.
        - **시퀀셜(Sequential) 프리패칭 :** 단순히 연속된 메모리 주소를 순차적으로 읽어야 하는 경우 프리패칭이 유용하다.
- 미세 공정 발전
    - 반도체 제조 공정을 10nm,7nm,5nm,3nm 등으로 미세화해서 더 많은 트랜지스터를 동일 면적에 집적한다.
    - 트랜지스터의 집적도가 높아져서 코어 수 증가, 캐시 용량 확대, 전력 효율 상승 등 여러 측면에서 성능 향상