## 명령어 파이프라인

- 명령어 파이프라인을 이해하려면 하나의 명령어가 처리되는 전체 과정을 비슷한 시간 간격으로 나누어 보아야 한다. 명령어 처리 과정을 클럭 단위로 쪼개면 다음과 같다.
    - 명령어 인출 (Fetch)
    - 명령어 해석 (Decode)
    - 명령어 실행 (Instruction)
    - 결과 저장 (Write Back)
- 여기서 핵심은 명령어 끼리 같은 단계로 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있다는 것이다. 이 기법을 명령어 파이프라이닝이라고 한다.

![명령어1](https://github.com/user-attachments/assets/1b15fe78-ef93-461a-8c50-5f3919035b71)
- 파이프라이닝은 높은 성능을 가져오지만, 특정 상황에서는 실패한다. 이러한 상황을 파이프라인 위험이라고 하고, 데이터 위험, 제어 위험, 구조적 위험이 존재한다.

### 데이터 위험

- 명령어 간 ‘데이터 의존성’에 의해 발생한다.
- 예를 들어 어떤 명령어는 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우가 있다.

    ```java
    r1 <- r2 + r3
    r4 <- r1 + r2
    
    이 상황에서는 r1 저장되고 나서야 다음 명령어를 실행할 수 있다. 그동안은 지연되어야 한다.
    ```

- 이 경우 파이프라인이 제대로 작동하지 않는다.

### 제어 위험

- 분기 등으로 인한 ‘프로그램 카운터의 갑작스러운 변화’에 의해 나타난다.
- 분기가 일어나면 파이프라이닝에 미리 가지고 와서 처리 중이었던 명령어들이 아무 쓸모가 없어진다. 이를 제어 위험이라고 한다.
- 이를 위해 분기 예측을 해서 미리 그 주소를 인출하는 기술도 있다.

### 구조적 위험

- 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 부품을 사용하려고 할 때 발생한다. 자원 위험이라고도 한다.
- 이를 위해서는 알아둬야 할 문제들이 많다

## 슈퍼스칼라

- 파이프라이닝은 단일 파이프라인으로도 가능하지만, 오늘날 대부분의 CPU에서는 여러 개의 파이프라인을 사용한다. 이처럼 CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 **슈퍼스칼라** 라고 한다.

![명령어2](https://github.com/user-attachments/assets/83a3f79a-9bbe-418d-a33c-7ae6b4f47e82)

- 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 슈퍼스칼라 CPU 라고 한다.
- 매 클럭 주기마다 동시에 여러 명령어들을 Fetch, Decode, Instruction 이 가능하다.
- 슈퍼스칼라 CPU 에서는 이론적으로 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라지지만, 이것도 무한정 빨라지지는 않는다. 여러 개의 파이프라인을 사용하면 데이터 위험, 제어 위험, 구조적 위험에 더 노출이 되기 때문이다.

## 비순차적 명령어 처리 (Out-Of-Order Excecution)

- 파이프라이닝, 슈퍼스칼라 모두 순차적으로 처리하는 명령어였음. 만약 모든 명령어를 순차적으로만 처리한다면 예상치 못한 상황에서 파이프라인이 멈추게 된다.
- 다음 예시를 보자.

```java
1. M(100) <- 1
2. M(101) <- 2
3. M(102) <- M(100) + M(101)

4. M(150) <- 1
5. M(151) <- 2
6. M(152) <- 3
```

- 이 상황에서 3번 명령어가 실행되기 위해서는 1,2번 명령어가 모두 Fetch, Decode , Instruction, Write Back 과정을 거치고 나서 실행되어야 한다. 3번 명령어는 지연되어야 한다.
- 하지만 4,5,6번 명령어의 경우 1,2,3 번 명령어와 관계없는 명령어여서 지연될 필요가 없는데도, 3번 명령어가 지연되고 있어서 실행하지 못하고 있다.
- 이렇게 순서를 바꿔서 실행해도 무관한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법을 **비순차적 명령어 처리**라고 한다.
- 하지만 아무 명령어니 순서를 바꿔서 처리하면 안되고, 명령어 사이의 어떠한 의존성도 없어야 순서를 바꿔도 전체 프로그램의 실행 흐름에 영향이 없다.