# 명령어 집합

- 명령어의 세세한 생김새, 연산, 주소 지정 방식은 CPU 마다 조금씩 다르다.
- CPU가 이해할 수 있는 명령어들의 모음을 명렁어 집합 구조(Instruction Set Architecture) 이라고 한다. 이하에서는 ISA로 줄여서 사용한다.

> 간단히 설명해서 인텔 cpu의 명령어를 그대로 아이폰의 ARM cpu은 이해하지 못한다는 말이다!
>
- ISA가 달라지면 각 CPU가 이해하는 어셈블리어도 달라진다는 말이다. (어셈블리어는 사용하는 컴파일러에 따라서도 바뀔 수 있다)
- ISA는 CPU 의 언어이기도 하면서, CPU를 비롯한 하드웨어가 소프트웨어를 어떻게 잉해할지에 대한 약속이기도 하다.
- ISA에 따라서 명령어 병렬 처리 기법이 용이하기도 하고, 그렇지 않기도 하다. 대표적인 ISA의 양대 산맥을 만나보자.

## CISC (Complex Instruction Set Computer)

### 특징

- 인텔의 x86, x86-64는 대표적인 CISC 기반의 ISA이다.
- CISC는 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 아주 다양한 **가변 길이 명령어**를 사용한다. 메모리에 접근하는 주소 지정 방식도 다양하다.

### 장점

- 그렇기 때문에 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다.
- 이런 장점때문에 CISC는 메모리를 최대한 아끼며 개발을 해야 했던 과거에는 큰 인기를 끌었다.

### 단점

- 하지만 CISC는 치명적인 단점이 있었는데, 명령어 수행 시간이 길고 각자 길이도 다르기 때문에 파이프라인이 효율적으로 명령어를 처리할 수 없다. (== 명령어가 규격화되어 있지 않음)
- 현대 CPU에게 명령어 파이프라인은 높은 성능을 위한 핵심 기술이기에 문제가 있음
- 더구나 복잡하고 다양한 명령어를 활용할 수는 있지만, 전체의 20% 명령어 정도만 자주 사용된다고 하니 이런 장점 또한 희미해진다.
- 따라서 CISC을 통한 CPU의 성장에는 한계가 존재한다.

## RISC(Reduced Instruction Set Computer)

- CISC에서 얻은 교훈은 2가지이다
    - 빠른 처리를 위해 파이프라인을 십분 활용해야 한다. 이를 위해서는 명령어 길이와 수행 시간이 짧고 규격화 되어야 한다.
    - 어차피 자주 쓰이는 명령어만 줄곧 사용된다. 자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것이 중요하다.
- 이름처럼 RISC는 명령어의 종류가 적고, 짧고 규격화된 명령어 (1클럭 이내)를 가지고 있다. 즉, **고정 길이 명령어**를 사용한다.
- 그렇게 때문에 파이프라이닝에 최적화되어 있다.

<aside>
💡
RISC는 메모리에 접근하는 명령어를 load, store 2가지로만 접근해서 메모리 접근을 단순화하고 최소화하였다. 그렇기 때문에 CISC보다 주소 지정 방식의 종류가 적다.
</aside>

- CISC 에 비해 필요한 명령어의 수가 많아서 같은 소스 코드를 컴파일해도 코드 길이가 더 길다