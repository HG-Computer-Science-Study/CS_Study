## 파일 시스템?

- 파일과 디렉터리를 보조기억장치에 저장하고 접근할 수 있게 하는 운영체제 내부 프로그램이다.
- 파일 시스템에는 다양한 종류가 있고, 하나의 컴퓨터에서 여러 파일 시스템을 사용할 수 있다.

## 파티셔닝

- 저장 장치의 논리적인 영역을 구획하는 작업을 의미한다.
    - 파티셔닝을 하기 전에는 보조기억장치에 곧바로 파일을 생성하거나 저장할 수 없다!
- 하드디스크나 SSD처럼 용량이 큰 저장 장치를 하나 이상의 논리적인 단위로 구획한다.
- 영역 하나하나를 **파티션**이라고 한다.
- 파일 시스템에는 여러 종류가 있고, 파티션마다 다른 파일 시스템을 설정할 수 있다.

## 포매팅

- 파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할 것인지를 결정하고, 새로운 데이터를 쓸 준비를 하는 작업을 의미한다.

<aside>
💡

포매팅의 종류에는 **저수준 포매팅**과 **논리적 포매팅**이 있다. 전자는 저장 장치를 생성할 당시 공장에서 수행되는 물리적인 포매팅이고, **후자는 파일 시스템을 생성하는 포매팅**이다. 여기서는 후자를 말한다.

</aside>

- 파티셔닝과 포매팅은 동시에 진행되는 경우가 많고, 보통은 이미 포매팅까지 완료되어 판매되긴 한다.

## 파일 할당 방법

- 운영체제는 파일과 디렉터리를 **블록 단위**로 읽고 쓴다.
    - 하드 디스크의 가장 작은 단위는 섹터이지만, 운영체제는 하나 이상의 섹터를 블록 단위로 묶어서 관리한다. (섹터는 너무 작고 많기 때문)
- 파일을 보조기억장치에 할당하는 방식은 크게 연속 할당과 불연속 할당이 있다. 불연속 할당은 다시 연결 할당, 색인 할당으로 나뉜다.

  ![Image](https://github.com/user-attachments/assets/4e1619fa-3b9f-4800-acaf-fcea03d80f01)

    - 오늘날에는 불연속 할당이 사용된다.

### 연속 할당

- 보조기억장치 내 연속적인 블록에 파일을 할당하는 방식이다.
- 연속으로 할당된 파일에 접근하기 위해서는 **파일의 첫 번째 블록 주소**와 **블록 단위의 길이**만 알면 된다. 그렇기에 디렉터리 엔트리에도 첫 번째 블록 주소와 블록 단위의 길이를 명시한다.

![Image](https://github.com/user-attachments/assets/8a17024e-4a46-46a6-a1b7-630842af2cd3)

- 구현이 간편하다는 장점이 있지만 외부 단편화를 야기한다는 단점이 있다.

### 연결 할당

- 연속 할당의 문제를 해결할 수 있는 방식이다.
- 각 블록의 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당하는 방식이다. (마치 연결 리스트처럼)
- 디렉터리 엔트리만 보아도 어떤 파일이 어디에 저장되어 있는지 확인할 수 있다.

![Image](https://github.com/user-attachments/assets/1b75a8ce-a071-4645-853c-1b7840d967c9)

- 이 또한 단점이 존재한다.
    - 반드시 첫 번째 블록부터 순서대로 읽어야 한다.
        - 파일의 중간 부분부터 접근하고 싶어도 반드시 파일의 첫 번째 블록부터 접근해야 한다.
        - 이는 임의 접근 속도가 매우 느리다는 뜻이다. 성능 면에서 비효율적이다.
    - 하드웨어 고장이나 오류 발생 시 해당 블록 이후 블록은 접근할 수 없다.
        - 다음 블록 주소에 접근할 수 없게 되면 이후 블록에 접근할 수 없다.
        - 하드 디스크는 정교하고 고장에 예민해서 큰 단점으로 다가온다.
- 그래서 연결 할당을 변형한 FAT 파일 시스템을 사용한다. 그 전에 색인 할당을 먼저 알아보자.

### 색인 할당

- 모든 블록 주소를 색인 블록에 모아 관리하는 방식이다.

![Image](https://github.com/user-attachments/assets/e2e47a12-45fb-4367-98f5-dc0c0ef79df7)

- 파일 a의 색인 블록이 4번이고, 파일 a의 데이터는 7,13,11 번 블록에 저장되어 있는 상황이다.
- 파일 a에 순차적으로 접근하고 싶다면 색인 블록에 저장된 주소에 순차적으로 접근하면 되고, i번째에 접근하고 싶다면 i번째에 접근하면 된다.
- 그렇기에 색인 할당을 사용하는 디렉터리 엔트리에는 파일 이름과 더불어 **색인 블록 주소를 명시**한다.

## FAT(File Allocation Table) 파일 시스템

- 각 블록에 포함된 다음 블록의 주소를 한데 모아 테이블 형태로 관리한다.

![Image](https://github.com/user-attachments/assets/4f54e75c-a8fd-46a8-9cfc-aaaee9f90d81)

- FAT 파일 시스템은 블록을 표현하는 비트 수에 따라 FAT12, FAT16, FAT32 로 나뉜다.
- FAT 파일 시스템에서 FAT는 파티션의 앞부분에 만들어진다. 하드 디스크의 한 파티션을 FAT 파일 시스템으로 포맷하면 해당 파티션이 다음과 같이 구성된다고 이해하면 된다.
- 아래 그림은 FAT 파일 시스템을 사용하는 파티션을 간략화한 도식도이다.
    - FAT 영역에 FAT가 저장되고, 루트 디렉터리가 그 뒤에 저장되고, 그 뒤에 서브 디렉터리와 파일들을 위한 영역이 있다.

![Image](https://github.com/user-attachments/assets/42986435-95a0-42a1-b2e5-a8ef3b05dbac)

- FAT는 하드 디스크 파티션의 시작 부분에 있지만, 메모리에 캐시되어 기존 연결 할당보다 다음 블록을 찾는 속도가 매우 빨리질 수 있다.

### FAT 예제

![Image](https://github.com/user-attachments/assets/63313976-5af1-4071-adcf-338ef40c746b)

1. 루트 디렉터리에 접근한다. (루트 디렉터리 영역)
2. home 디렉터리는 3번에 위치한다.
3. minchul 디렉터리는 15번에 위치한다.
4. [a.sh](http://a.sh) 파일은 9번에 위치한다.
5. FAT 를 참고하면 9 → 8 → 11 → 13번을 참조한다.

## 유닉스 파일 시스템

![Image](https://github.com/user-attachments/assets/cd1dc63d-bd1c-4701-a7a9-89a724b26fc1)

- 색인 할당 기반 파일 시스템이다.
- 여기서 색인 블록은 **i-node** 라고 한다.
- 파일마다 속성 정보와 15개의 블록 주소를 저장할 수 있다.
- 파일마다 i-node를 가지고 있고 고유한 번호가 부여되어 있으며, 이것만 봐도 어떤 파일이 어떤 속성을 가지며 어디에 저장되어 있는지도 알 수 있다.
- 디렉터리 엔트리에는 i-node 번호와 파일 이름이 저장된다.
- 파티션 내에 특정 영역에 모여서 저장되어 있다.

![Image](https://github.com/user-attachments/assets/2068be50-f7e4-43e5-817b-338910b381b8)

> **그런데 15개 이상의 블록이 필요한 파일을 저장해야 한다면?**
>
1. 블록 주소 중에서 1~12번 블록에는 직접 블록 주소를 저장한다.
2. 1번으로 충분하지 않다면 13번째 주소에는 단일 간접 주소를 저장한다. (저장된 파일 데이터의 위치를 가리킴)
3. 2번으로 충분하지 않다면 14번째 주소에는 이중 간접 블록을 저장한다.
4. 3번으로 충분하지 않다면 15번째 주소에는 삼중 간접 블록을 저장한다. (2개의 이중 간접 블록을 가리킴)

---

![Image](https://github.com/user-attachments/assets/6f835ba2-e694-4fd9-a294-19d2c87f1426)

1. 루트 i-node 접근 ⇒ 루트 디렉터리 영역에 접근 ⇒ home i-node == 3 번임을 체크
2. 3번 i-node에 접근 , minchul i-node == 8번임을 파악
3. minchul i-node 8번에 접근, a.sh의 i-node == 9번임을 파악
4. [a.sh](http://a.sh) i-node 9번에 접근, 98번, 12번, 13번 읽으면 된다.

<aside>
💡

윈도우에서 사용하는 NT 파일 시스템 (NTFS), 리눅스에서 사용하는 ext 파일 시스템 등도 있음.

</aside>

## 저널링 파일 시스템

- 만약 컴퓨터가 강제종료된다면(시스템 크래시) 파일 시스템이 손상될 수 있음.
- 이러한 상황에서 작업 로그를 통해 시스템 크래시가 발생했을 때 빠르게 복구할 수 있음.
    1. 작업 직전 파티션의 로그 영역에 수행하는 작업(변경 사항)에 대한 로그를 남긴다.
    2. 로그를 남긴 후 작업을 수행한다.
    3. 작업이 끝났다면 로그를 삭제한다.
- 이 경우 시스템 크래시가 발생하여 다시 부팅을 해야 한다면 파일 시스템은 전체를 검사할 필요 없이 로그 영역에 남긴 로그만 검사해도 된다.
    - 로그 영역을 읽어서 크래시가 발생한 당시 어떤 작업을 하고 있었는지 알아내 해당 작업만 완료하면 되기 때문이다.
- 현재 대부분의 파일 시스템은 저널링 기능을 지원한다.

## 마운트

유닉스, 리눅스 등의 운영체제에서 물리적인 장치를 특정한 위치(대개는 디렉터리)에 연결시켜주는 과정을 마운트라고 한다.

- 예를 들어 USB를 연결해야 한다고 할 때 임의의 파일의 경로가 `/etc/abc.txt` 라고 하자. 마운트 경로가 `/mnt` 라고 한다면, 파일 시스템은 마운트 후 `/mnt/etc/abc.txt` 경로로 파일에 접근할 수 있다.