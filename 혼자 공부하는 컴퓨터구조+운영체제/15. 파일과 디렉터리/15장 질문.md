# 하드 링크와 심볼릭 링크의 개념과 차이점

- 모두 리눅스에서 사용되는 링크라는 공통점이 있다.
- 링크는 파일을 가르킨다.

## 하드 링크

- 원본 파일과 동일한 i-node를 가리킨다.
- 원본 파일이 삭제되어도 다른 하드 링크를 통해 여전히 데이터에 접근할 수 있다.
- 파일의 inode마다 링크 카운트(Link Count)가 존재해서 그 파일을 가리키고 있는 다른 파일의 개수를 알 수 있다.
    - Link Count == 3 이라면 현재 그 파일을 가리키고 있는 파일 (링크) 가 3개라는 뜻이다. (원본 파일을 포함하여)
- 동일한 파일시스템 내에서만 하드링크 생성가능.

## 소프트 링크

- 원본 파일을 가리키는 또 다른 i-node를 생성한다.
- 대상 파일의 inode가 아닌 대상 파일의 데이터 경로만을 참조.
- 원본 파일이 사라지면 해당 데이터에 접근할 수 없다.

![Image](https://github.com/user-attachments/assets/d75a46be-a81a-446c-b23d-5cfffe736e39)

- i-node block 과 data block 은 디스크 내의 파티션 중 일부이다!

## 링크는 결국 C 언어의 포인터와 같다.

### 하드 링크 ⇒ Call by Value

```java
int aa = 1000; // aa라는 파일이 inode 1000을 가리키고 있음
int bb = aa; // bb 하드링크라는 파일도 같이 inode 1000을 가리키도록 지정함

aa = null; // aa파일이 파괴됨
printf(bb); // 1000; bb 하드링크는 아무런 영향 없음
```

### 소프트 링크 ⇒ Call by Reference

```java
int aa = 1000; // aa라는 파일이 1000 값을 가리키고 있음
int *bb = &aa; // bb 심볼릭 링크도 똑같이 1000값을 가리키도록 함

aa = null; // 대상파일 aa가 파괴됨
printf(bb) // null; bb 심볼릭 링크 값도 파괴되어 있음
```