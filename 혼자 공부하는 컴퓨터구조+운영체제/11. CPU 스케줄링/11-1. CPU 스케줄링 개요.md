### 키워드

`CPU 스케줄링`, `우선순위`, `스케줄링 큐`, `준비 큐`, `대기 큐`, `선점형 스케줄링`, `비선점형 스케줄링`

### 시작하기 전에

- **CPU 스케줄링** : 운영체제가 프로세스들에게 CPU 자원을 배분하는 것

# 프로세스 우선순위

### 입출력 집중 프로세스와 CPU 집중 프로세스

- **입출력 집중 프로세스** : 입출력 작업이 많은 프로세스
  - 비디오 재생, 디스크 백업
  - 입출력 대기 상태 > 실행 상태
- **CPU 집중 프로세스** : CPU 작업이 많은 프로세스
  - 수학 연산, 컴파일, 그래픽 처리 작업
  - 대기 상태 < 실행 상태

<aside>
💡

**CPU 버스트와 입출력 버스트**

- CPU 버스트 : CPU를 이용하는 작업
- 입출력 버스트 : 입출력자이를 기다리는 작업
- 프로세스는 CPU 버스트와 입출력 버스트를 반복하며 실행된다
</aside>

### 입출력 집중 프로세스의 우선순위가 더 높다

- 입출력 집중 프로세스를 빨리 실행시켜 입출력장치를 끊임없이 작동시키고, CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 효율적이기 때문이다.

### 우선순위

- 운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.

# 스케줄링 큐

- 운영체제가 모든 프로세스의 PCB를 검사하여 프로세스 처리 순서를 결정하는 것은 비효율적이다.
- 운영체제는 **스케줄링 큐**를 통해 프로세스들을 관리한다
  ![Image](https://github.com/user-attachments/assets/af8ff038-8910-4e97-b878-7947ebcf85b3)
  - 참고 : 스케줄링 큐는 반드시 FIFO 방식일 필요는 없다

### 스케줄링 큐의 종류

- **준비 큐** : CPU를 이용하고 싶은 프로세스들을 관리
- **대기 큐** : 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들을 관리

![Image](https://github.com/user-attachments/assets/4b784802-d457-43e5-8d34-d83e77e2f241)

### 우선순위 고려

- 운영체제는 위 그림과 같이 PCB들이 큐에 삽입된 순서대로 프로세스를 실행하되, 우선순위가 높은 프로세스를 먼저 실행한다.

### 입출력 프로세스의 실행 방식

![Image](https://github.com/user-attachments/assets/b748e782-af5c-4596-a8ba-2d28ba164b8d)

1. 각 프로세스는 입출력이 완료될 때까지 대기 큐에서 기다린다
2. 입출력 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거한다
3. 해당 PCB는 준비 큐로 이동한다.

### 프로세스 상태 다이어그램

![Image](https://github.com/user-attachments/assets/47c2b5f2-34da-4a9e-b2c0-b8cdde1fd3ad)

# 선점형과 비선점형 스케줄링

- 상황 : 프로세스 A가 CPU를 사용하는 중, 프로세스 B가 당장 CPU 사용하기를 요청한다면?
- **선점형 스케줄링** : 프로세스 A로부터 자원을 빼앗아 프로세스 B에 할당할 수 있는 스케줄링 방식
  - 어느 하나의 프로세스가 자원 사용을 독점할 수 없는 방식
  - 예시 : 프로세스마다 정해진 시간만큼 CPU를 사용하고, 정해진 시간을 모두 소비하여 타이머 인터럽트가 발생하면 운영체제가 해당 프로세스로부터 CPU 자원을 빼앗아 다음 프로세스에 할당하는 방식
- **비선점형 스케줄링** : 프로세스 A가 종료되거나 대기 상태에 접어들기 전까지는 프로세스 B가 끼어들 수 없는 스케줄링 방식
  - 하나의 프로세스가 자원 사용을 독점할 수 있는 방식

### 장단점

- 선점형 스케줄링
  - 장점 : 특정 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다
  - 단점 : 문맥 교환 과정에서 오버헤드 발생
- 비선점형 스케줄링
  - 장점 : 문맥 교환에서 발생하는 오버헤드가 적음
  - 단점 : 프로세스들이 자원을 골고루 사용할 수 없다.
