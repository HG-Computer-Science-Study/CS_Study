## 1. 서버를 이중화, 혹은 다중화를 하게 되는 경우 각 서버가 가지고 있는 정보들을 동기화할 수 있는 방법

1. **데이터베이스 레벨에서의 동기화**

   - **마스터-슬레이브 복제(Master-Slave Replication)**
     - 한 서버를 마스터로 두고 나머지를 슬레이브로 설정. 마스터에서 데이터가 업데이트되면 슬레이브로 복제됨.
     - **장점**: 단방향 복제로 성능이 좋음.
     - **단점**: 슬레이브에서는 쓰기가 불가능하며, 쓰기 작업이 많을 경우 병목 현상이 발생.
   - **마스터-마스터 복제(Master-Master Replication)**
     - 모든 서버에서 읽기와 쓰기가 가능하며, 데이터를 상호 복제함.
     - **장점**: 다중 쓰기 지원.
     - **단점**: 충돌 관리가 필요.
   - **분산 데이터베이스**
     - NoSQL DB나 분산형 SQL DB같은 분산 데이터베이스를 사용해 기본적으로 데이터 동기화를 처리.

2. **파일 및 객체 스토리지 동기화**

   - **네트워크 파일 시스템(NFS)**
     - 여러 서버가 같은 스토리지를 마운트하여 공유.
     - **장점**: 설정이 간단하고 파일 동기화가 실시간으로 이루어짐.
     - **단점**: NFS 서버가 단일 장애점(Single Point of Failure)이 될 수 있음.
   - **분산 파일 시스템(GlusterFS, Ceph)**
     - 데이터를 여러 서버에 분산 저장하고 복제를 통해 동기화.
     - **장점**: 고가용성 지원.
     - **단점**: 설정이 복잡하고 추가적인 네트워크 리소스 필요.
   - **클라우드 스토리지**
     - AWS S3, Google Cloud Storage와 같은 클라우드 기반 스토리지를 이용해 중앙화된 데이터 저장소 관리.

3. **캐시 동기화**

   - **Redis Cluster 또는 Sentinel**
     - Redis를 클러스터로 구성해 데이터를 샤딩하거나 복제.
     - **장점**: 빠른 동기화와 고가용성.
     - **단점**: 메모리 사용량이 많아질 수 있음.
   - **Kafka 및 메시지 큐**
     - 서버 간 동기화 메시지를 Kafka나 RabbitMQ와 같은 메시지 큐로 전달.
     - **장점**: 비동기적이고 확장성 높음.
     - **단점**: 시스템 복잡도 증가.

4. **애플리케이션 레벨에서의 동기화**

   - **API 및 웹훅(Webhooks)**
     - 한 서버에서 데이터를 변경하면 동기화가 필요한 다른 서버에 API 요청이나 웹훅을 통해 알림을 보냄.
     - **장점**: 커스텀 로직 구현 가능.
     - **단점**: 설정과 유지보수가 복잡할 수 있음.
   - **데이터 이벤트 기반 동기화(Event-Driven Architecture)**
     - 서버에서 데이터 변경 이벤트를 발생시키고 이를 다른 서버들이 수신하도록 구성.
     - Kafka, RabbitMQ 등과 같은 메시지 브로커 사용.

5. **로드 밸런서 기반 세션 동기화**

   - **세션 스티키(Session Sticky)**
     - 클라이언트 요청이 항상 같은 서버로 라우팅되도록 설정해 동기화 필요성을 줄임.
   - **세션 공유**
     - Redis, Memcached 같은 중앙 세션 저장소를 사용해 모든 서버가 같은 세션 데이터를 공유.

6. **헬스 체크 및 상태 동기화**

   - **Consul, Etcd, Zookeeper**
     - 서버 상태와 구성 정보를 실시간으로 동기화하고 관리.
     - **장점**: 분산 환경에서 설정과 상태 정보를 손쉽게 관리.
     - **단점**: 추가적인 학습 및 설정 필요.

## 2. 고가용성(HA)을 보장하기 위해 설계된 시스템에서 단일 장애점(SPOF)을 완전히 제거하려면 어떤 전략과 기술이 필요한가?

### 1. 단일 장애점을 완전히 제거 가능한가?

단일 장애점(Single Point of Failure, SPOF)을 완전히 제거하는 것은 이론적으로는 가능하지만, 현실적으로는 매우 어렵다. 이유는 시스템의 모든 구성 요소에서 SPOF를 제거하려면 비용, 복잡성, 물리적 제한 등이 크게 증가하기 때문이다.

1. 전력, 네트워크 인프라, DNS 서버 등 물리적 또는 네트워크 기반 자원은 완전히 중복화하기 어렵다.

   - 예: 데이터센터 자체가 장애를 겪는 경우(Major Outage).

2. SPOF를 제거하려면 모든 요소에 중복성(이중화, 삼중화 등)을 추가해야 하며, 이는 유지 비용과 관리 복잡성을 증가시킨다.

3. 복제 및 분산 시스템에서도 데이터 동기화 문제, 잠금 충돌, 지연 등이 발생할 수 있다.
   - 예: 데이터베이스의 글로벌 락 문제.

---

### 2. SPOF 발생 가능성을 낮추고, 장애 발생 시 빠르게 복구할 수 있도록 설계하는 것이 현실적이다.

1. **이중화 및 다중화**

   - 서버, 네트워크 장비, 데이터 저장소를 중복화하여 장애 시 대체 가능하게 설계.
   - 예: Active-Active 클러스터, Active-Passive 복제.

2. **지리적 분산**

   - 데이터센터를 지역적으로 분산 배치(Multi-Region, Multi-AZ)하여 특정 지역의 장애에도 대응.
   - 예: AWS Multi-AZ 배포, CDN(Content Delivery Network).

3. **자동 장애 조치(Failover)**

   - 장애 발생 시 자동으로 대체 자원으로 전환.
   - 예: DNS Failover, Redis Sentinel.

4. **모니터링 및 복구 자동화**

   - Prometheus, Grafana 등의 도구를 사용해 장애를 실시간 감지 및 대응.
   - 장애 발생 후 복구 작업(서버 재배치 등)을 자동화.

5. **테스트 및 시뮬레이션**
   - 정기적으로 Chaos Engineering을 통해 장애 상황을 시뮬레이션하고 취약점을 개선.
   - 예: Netflix의 Chaos Monkey.

## 3. TLS 핸드셰이크 과정에서 클라이언트와 서버는 어떻게 안전하게 세션 키를 교환하며, 이 과정에서 대칭 키 암호화와 공개 키 암호화는 각각 어떤 역할을 하는가?

### 1. 클라이언트와 서버가 세션 키를 교환하는 과정

1. 초기 핸드셰이크 단계:

   - 클라이언트가 서버에 연결을 시도하며 지원 가능한 암호화 스위트(cipher suite) 목록을 전송
   - 서버는 이 중 하나를 선택하고 자신의 디지털 인증서를 클라이언트에 전송
   - 이 인증서에는 **서버의 공개키**가 포함되어 있음

2. 키 교환 과정:

   - 클라이언트는 임시 난수(Pre-Master Secret)를 생성
   - **서버의 공개키를 사용해 이 Pre-Master Secret을 암호화**
   - 암호화된 Pre-Master Secret을 서버에 전송
   - **서버는 자신의 개인키로 이를 복호화**

3. 세션 키 생성:

   - 양측은 교환된 Pre-Master Secret과 이전에 교환한 난수들을 조합하여 **동일한 세션 키를 생성**
   - 이 세션 키가 이후 통신에서 사용될 **대칭키**가 됨

### 2. 공개키 암호화와 대칭키 암호화의 역할

1. 공개키 암호화(비대칭):

   - 핸드셰이크 초기 단계에서 안전한 키 교환을 위해 사용
   - Pre-Master Secret을 안전하게 전송하는 데 활용
   - 중간자 공격을 방지하고 통신의 기밀성을 보장

2. 대칭키 암호화:

   - 실제 데이터 통신 시 사용
   - 생성된 세션 키로 양방향 통신을 암호화
   - 처리 속도가 빨라 대용량 데이터 전송에 적합

이러한 하이브리드 방식을 통해 TLS는 보안성과 효율성을 모두 확보할 수 있다. 공개키 암호화로 안전한 키 교환을 보장하고, 이후 통신은 더 효율적인 대칭키 암호화를 사용하는 방식이다.

## 4. 와이파이에서 AP가 비컨 프레임을 주기적으로 전송하는 이유는 무엇이며, 비컨 프레임에 포함된 정보는 어떤 역할을 하는가?

### 1. 비컨 프레임 전송 목적

1. 네트워크 존재 알림

   - AP가 자신의 존재를 주변 기기들에게 주기적으로 알림
   - 일반적으로 100ms 간격으로 전송되어 실시간 네트워크 가용성 보장
   - 새로운 기기들이 근처의 사용 가능한 네트워크를 발견할 수 있게 함

2. 동기화 유지

   - 네트워크에 연결된 모든 기기들의 시간 동기화 지원
   - 파워 세이브 모드의 기기들이 깨어나야 할 정확한 시점 파악 가능

### 2. 비컨 프레임에 포함된 주요 정보

1. 네트워크 식별 정보

   - SSID (네트워크 이름)
   - BSSID (AP의 MAC 주소)
   - 채널 번호

2. 타이밍 정보

   - 타임스탬프: 시간 동기화용
   - 비컨 간격: 다음 비컨 전송까지의 시간
   - TIM(Traffic Indication Map): 대기 중인 데이터 정보

3. 성능 관련 정보

   - 지원하는 데이터 전송률
   - 사용 중인 암호화 방식
   - QoS 능력
   - 지원하는 802.11 표준 버전

4. 네트워크 운영 파라미터

   - 경쟁 구간/비경쟁 구간 정보
   - 전력 관리 정보
   - 로밍 관련 정보

이러한 정보들의 역할:

- 클라이언트 기기들이 네트워크 접속 전에 호환성 확인 가능
- 최적의 연결 설정 선택 지원
- 효율적인 전력 관리 가능
- 원활한 로밍 지원
- 네트워크 보안 설정 확인 가능

비컨 프레임은 와이파이 네트워크의 기본적인 관리와 운영을 위한 필수적인 제어 메커니즘을 제공하며, 클라이언트 기기들의 효율적이고 안정적인 네트워크 접속을 가능하게 한다.
